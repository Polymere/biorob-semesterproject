import sys
import yaml
import numpy as np
import pandas as pd
import os
import time

from shutil import copyfile

from run_batch_controller.run_launcher import CppLauncher

from utils.file_utils import assert_file_exists,assert_dir

from data_analysis.process_run import CppRunProcess,PythonRunProcess

from optimisation.optimizers import PSOptimizer,GAOptimizer,NSGAIIOptimizer

NORUNMODE=False
if NORUNMODE:
	ROOT_RESULT_DIR = "./trash"
else:
	ROOT_RESULT_DIR = "/data/prevel/runs"

import warnings
warnings.filterwarnings('ignore') # pandas warning a utter trash

LOG_DEBUG=1
LOG_INFO=2
LOG_WARNING=3
LOG_ERROR=4
LOG_LEVEL=LOG_INFO

class NewEvolutionController():
	"""docstring for ClassName"""
	run_launcher=None
	run_processor=None
	max_nb_gen=100
	nb_ind=10
	cross_rate=0.1
	mut_rate=1.0
	mut_amp=10
	dofs={"G_SOL":(0,2.0),
			"G_GAS":(0,2.0)}#"GSOL":(0,100)}

	optimizer_name="NSGAII"
	init_pop_mode="rand"
	# Random values within boundaries
	bound_mod="clip" 
	# only valid one for now, maybe allow going above boundaries (soft boundaries) for a certain cost (optimization param)
	
	def __init__(self, ev_config):

		self.__dict__.update(ev_config)

		self.trial_dir = os.path.join(ROOT_RESULT_DIR, time.strftime("%j_%H:%M"))
		assert_dir(self.trial_dir,should_be_empty=True)

		del ev_config["worlds_path"]
		del ev_config["log_paths"]
		del ev_config["param_paths"]
		with open(os.path.join(self.trial_dir,"ev_params.yaml"),"w+") as outparams:
			yaml.dump(ev_config,outparams,default_flow_style=False)

		if self.optimizer_name=="NSGAII":
			self.union_pop=True
			self.opti=NSGAIIOptimizer(ev_config)
		elif self.optimizer_name=="GA":
			self.union_pop=False
			self.opti=GAOptimizer(ev_config)
		elif self.optimizer_name=="PSO":
			self.union_pop=False
			self.opti=PSOptimizer(ev_config)
		else:
			if LOG_LEVEL<=LOG_ERROR:
				print("\n[ERROR]Unknown optimizer name\n",self.optimizer_name)
			raise ValueError

		self.nb_gen=0
		self.flatten_params()
		self.current_pop=None

	def set_init_pop(self):

		uids=["gen"+str(self.nb_gen)+"ind"+str(i+1) for i in range(self.nb_ind)]
		pop_df=pd.DataFrame(index=uids,columns=self.dofs.keys())
		if self.init_pop_mode=="rand":
				vals=(self._bound_high-self._bound_low)*np.random.rand(self.nb_ind,len(self._bound_low)) - self._bound_low
				pop_df[:]=vals
				return pop_df
		elif self.init_pop_mode=="one_parent":
			"""
				initial population is generated by mutating a reference parent (working initial parameter set)
				"""
			if self.initial_pop is None:
				raise ValueError
			print("\n[INFO]Initializing population from parent\n",self.initial_pop)
			for index, row in pop_df.iterrows():
				pop_df.loc[index]=self.initial_pop
			select_ids=pop_df.head(1)
			return self.opti.get_next_gen(select_ids,self.nb_gen)
		elif self.init_pop_mode=="multiple_parent":
			""" 
				initial population is generated by mutation and crossover of a full parent population
				can be used to restart evolution from a certain generation
				"""
			if self.initial_pop is None:
				raise ValueError
			return elf.opti.get_next_gen(select_ids,self.nb_gen)
		else:
			raise KeyError
			
	def init_pop(self):
		raise DeprecationWarning
		self.set_init_pop()
		eval_pop=self.eval_pop(self.current_pop)
		parents=self.opti.select(self.opti.sort_pop(eval_pop))
		if LOG_LEVEL<=LOG_INFO:
			print("\n[INFO]Gen",self.nb_gen," Parents\n",parents)
		self.nb_gen+=1	
		return self.opti.get_next_gen(parents,self.nb_gen)


	def evolve(self):
		childrens=self.set_init_pop()
		parents=None
		while not self.is_stop():
			print("\n[INFO]***************GEN",self.nb_gen,"***************\n")
			eval_pop=self.eval_pop(childrens)
			if self.union_pop and parents is not None:
				candidates=pd.concat([eval_pop,parents],axis=0)
			else:
				candidates=eval_pop
			parents=self.opti.select(self.opti.sort_pop(candidates))
			if LOG_LEVEL<=LOG_INFO:
				print("\n[INFO]Gen",self.nb_gen," Parents\n",parents)
			self.nb_gen+=1
			childrens=self.opti.get_next_gen(parents,self.nb_gen) # drop fitnesses and cr_dist for check_bound
			if self.is_stop():
				parents.to_csv(os.path.join(self.trial_dir,"parents_gen"+str(self.nb_gen)+".csv"))


	def eval_pop(self,population,verbose=False):
		if verbose:
			print("\n[INFO]Local evaluation, population\n",population)
		self.run_launcher.create_pop(population.to_dict(orient="index"),
									self.param_paths,
									self.log_paths)

		self.run_launcher.run_batch("worlds",self.worlds_path,self.log_paths)

		scores=self.run_processor.get_fitness_from_dir(self.log_paths)

		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]Pop\n",population)
			print("\n[DEBUG]scores\n",scores)

		saved_df=pd.concat([population,scores],axis=1)
		saved_df["gen"]=self.nb_gen
		saved_df.to_csv(os.path.join(self.trial_dir,"gen"+str(self.nb_gen)+".csv"))

		if self.opti.is_single_obj:
			scores["fitness"]=scores.filter(like="fit_").sum(1)
			evaluated=pd.concat([population,scores.fitness],axis=1)
		else:
			scores=scores.add(scores.fit_stable,axis='index')
			evaluated=pd.concat([population,scores.filter(self.objectives_metrics)],axis=1)

		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]Evaluated pop\n",evaluated)
		return evaluated

	def is_stop(self):
		if self.nb_gen>self.max_nb_gen:
			return True
	def flatten_params(self):
		nb_par=len(self.dofs)
		self._bound_low=np.empty(nb_par, np.float16)
		self._bound_high=np.empty(nb_par, np.float16)
		self._params=[]
		self.dof_names=[]
		i=0
		for dof_name,dof_bounds in self.dofs.items():
			self._bound_low[i]=dof_bounds[0]
			self._bound_high[i]=dof_bounds[1]
			self.dof_names.append(dof_name)
			i+=1





class NewCppEvolutionController(NewEvolutionController):
	def __init__(self,config_file):
		params=yaml.load(open(config_file, 'r'))
		NewEvolutionController.__init__(self,params)

		self.run_launcher=CppLauncher(params)
		self.run_processor=CppRunProcess(params)

if __name__ == '__main__':
	ev_file=sys.argv[1]
	model="cpp"
	

	if model=="cpp":
		config_file=os.path.join("../../data/references",ev_file)
		assert_file_exists(config_file, should_exist=True)
		c=NewCppEvolutionController(config_file)
		c.evolve()

	elif model=="cpp_debug":
		config_file=os.path.join("../../data/references",ev_file)
		assert_file_exists(config_file, should_exist=True)
		c=NewCppEvolutionController(config_file)
		LOG_LEVEL=LOG_DEBUG
		c.evolve()

		#c.sort_pop(pop)



## DEPRECATED
class EvolutionController():
	"""docstring for ClassName"""
	max_nb_gen=100
	nb_ind=10
	cross_rate=0.1
	mut_rate=1.0
	mut_amp=10
	dofs={"G_SOL":(0,2.0),
			"G_GAS":(0,2.0)}#"GSOL":(0,100)}
	init_pop_mode="rand"
	# Random values within boundaries
	bound_mod="clip" 
	# only valid one for now, maybe allow going above boundaries (soft boundaries) for a certain cost (optimization param)
	
	def __init__(self, ev_config):

		self.__dict__.update(ev_config)

		self.trial_dir = os.path.join(ROOT_RESULT_DIR, time.strftime("%j_%H:%M"))

		assert_dir(self.trial_dir,should_be_empty=True)
		with open(os.path.join(self.trial_dir,"ev_params.yaml"),"w+") as outparams:
			yaml.dump(self.__dict__)
		#print("############\n",self.__dict__,"\n############")
		self.run_launcher=None
		self.nb_gen=0
		self.flatten_params()
		self.current_pop=None
		self.start_time=time.time()


	def set_init_pop(self):

		uids=["gen"+str(self.nb_gen)+"ind"+str(i+1) for i in range(self.nb_ind)]
		pop_df=pd.DataFrame(index=uids,columns=self.dofs.keys())
		if self.init_pop_mode=="rand":
				vals=(self._bound_high-self._bound_low)*np.random.rand(self.nb_ind,len(self._bound_low)) - self._bound_low
				pop_df[:]=vals
				self.current_pop=pop_df
		elif self.init_pop_mode=="one_parent":
			"""
				initial population is generated by mutating a reference parent (working initial parameter set)
				"""
			if self.initial_pop is None:
				raise ValueError
			print("\n[INFO]Initializing population from parent\n",self.initial_pop)
			for index, row in pop_df.iterrows():
				pop_df.loc[index]=self.initial_pop
			select_ids=pop_df.head(1)
			self.current_pop=pop_df
			self.current_pop=self.cross_and_mutate(select_ids)
		elif self.init_pop_mode=="multiple_parent":
			""" 
				initial population is generated by mutation and crossover of a full parent population
				can be used to restart evolution from a certain generation
				"""
			if self.initial_pop is None:
				raise ValueError
			self.current_pop=self.cross_and_mutate(self.initial_pop)
		else:
			raise KeyError
			
	def init_pop(self):
		self.set_init_pop()
		eval_pop=self.eval_pop(self.current_pop)
		selected=self.select(self.sort_pop(eval_pop))
		self.current_pop=eval_pop
		self.nb_gen+=1
		self.childrens=self.cross_and_mutate(selected)


	def evolve(self):
		self.init_pop()
		while not self.is_stop():
			print("\n[INFO]***************GEN",self.nb_gen,"***************\n")

			eval_df=self.eval_pop(self.childrens)
			union_pop=pd.concat([eval_df,self.current_pop],axis=0)
			if LOG_LEVEL<=LOG_DEBUG:
				print("\n[DEBUG]Union\n",union_pop)
			new_parents=self.select(self.sort_pop(union_pop))
			print("\n[INFO] Parents \n:",new_parents)
			self.current_pop=eval_df
			self.nb_gen+=1
			self.childrens=self.cross_and_mutate(new_parents) # drop fitnesses and cr_dist for check_bound
			
			#union=None

			
	def check_bound(self,population):

		for index, row in population.iterrows():
			if LOG_LEVEL<=LOG_DEBUG:
				print("\n[DEBUG]check_bound\n",row)
			# clip boundaries
			if self.bound_mod=="clip":
				row=row+(row>self._bound_high)*(self._bound_high-row)
				row=row+(row<self._bound_low)*(self._bound_low-row)
				population.loc[index]=row.values
			elif self.bound_mod=="exp_handicap":

				handicap=	(row>self._bound_high)*(row-self._bound_high)+\
							(row<self._bound_low)*(self._bound_low-row)
				if LOG_LEVEL<=LOG_DEBUG:

					print("\n[DEBUG]handicap\n",handicap)
					print("\n[DEBUG]type\n",type(handicap))
					print("\n[DEBUG]type\n",type(handicap.values[0]))
				fl_handicap=np.sum(np.exp(handicap.values.astype(np.float))-1)
				if LOG_LEVEL<=LOG_DEBUG:
					print("\n[DEBUG]fl_handicap\n",fl_handicap)
				population.loc[index,"fit_handicap"]=-fl_handicap
		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]Boundaries\n",population)
		return population


	def cross_and_mutate(self,selected_parents):

		nb_dofs=len(self.dofs)

		couples=np.random.randint(0, len(selected_parents.index), (2,self.nb_ind))
		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]selected_parents\n",selected_parents)
			print("\n[DEBUG]couples\n",couples)
		p1_ids=selected_parents.iloc[couples[0][:]].index
		p2_ids=selected_parents.iloc[couples[1][:]].index

		cross_select=(np.random.randint(0,100,(self.nb_ind,nb_dofs))<100*self.cross_rate)
		# probability cross_rate to take a param from parent2 
		uids=["gen"+str(self.nb_gen)+"ind"+str(i+1) for i in range(self.nb_ind)]
		child_df=pd.DataFrame(index=uids,columns=self.dofs.keys())
		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]current_pop\n",self.current_pop.head())
		child_df[:]=(selected_parents.loc[p1_ids,self.dofs.keys()]*cross_select[:]).values+\
					(selected_parents.loc[p2_ids,self.dofs.keys()]*np.logical_not(cross_select[:])).values
		mutate=(np.random.randint(0,100,(self.nb_ind,nb_dofs))<100*self.mut_rate)
		# probability mutrate to add a normal of std value*mut_amp to param
		mutate_amp=np.random.randn(self.nb_ind,nb_dofs)*child_df[:]*self.mut_amp	
		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]Mutate increment\n",mutate_amp)
		child_df[:]=child_df[:]+mutate_amp*mutate
		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]Child\n",child_df)

		return self.check_bound(child_df)

	def select(self,sorted_pop):
		#print("\n[INFO] Gen",self.nb_gen,"Fitnesses\n",sorted_pop.head(5))
		return sorted_pop.head(2)#["uid"]
	def sort_pop(self,eval_pop):
		pop_with_fronts=self.add_fronts(eval_pop)
		fronts_and_dist=self.add_crowding_distance(pop_with_fronts)
		sorted_pop=fronts_and_dist.sort_values(by=["front","cr_dist"],axis='index',ascending=[True,False])
		if LOG_LEVEL<=LOG_INFO:
			print("\n[INFO]Sorted population\n",sorted_pop)
		return sorted_pop

	def add_fronts(self,eval_pop):
		# fast non dominated sort
		fit=eval_pop.filter(like="fit_")
		#fit=fit.add(fit.fit_stable,axis='index')
		#fit.drop("fit_stable",axis=1,inplace=True)
		fronts=pd.DataFrame(columns=eval_pop.columns)
		flag_empty_front=False
		other=pd.DataFrame(columns=fit.columns)
		nb_front=1
		while not flag_empty_front:
			current_front=pd.DataFrame(columns=eval_pop.columns)
			for index, indiv in fit.iterrows():
				rel=fit.le(indiv,axis=1).drop(index)
				dominant=rel[(rel.all(axis=1)==True)==True].index
				rel=fit.gt(indiv,axis=1).drop(index)
				#print(rel)
				dominated=rel[(rel.all(axis=1)==True)==True].index
				if LOG_LEVEL<=LOG_DEBUG:
					print("\n[DEBUG]",index,"Dominates\n",dominant.values,"\nDominated by\n",dominated.values)
				if len(dominated)==0:
					current_front.loc[index,eval_pop.columns]=eval_pop.loc[index].values
					current_front.loc[index,"front"]=nb_front
				else:
					other.loc[index]=fit.loc[index].values
			if LOG_LEVEL<=LOG_DEBUG:
				print("\n[DEBUG]other\n",other)
			if LOG_LEVEL<=LOG_INFO:
				print("\n[INFO]Front",nb_front,"with",len(current_front),"inds\n")
				print("\n[INFO]",current_front)
				print("\n[INFO]Missing",len(other),"inds\n")
				print("\n[INFO]",other)
			

			fronts=fronts.append(current_front)
			flag_empty_front=(len(other)==0)
			fit=other
			other=pd.DataFrame(columns=fit.columns)
			nb_front+=1

		if LOG_LEVEL<=LOG_INFO:
			fronts=fronts[fronts.columns.drop(fronts.filter(like="Unnamed").columns)]
			print("\n[INFO]Fronts\n",fronts)
		
		return fronts

	
	def add_crowding_distance(self,pop_with_fronts):
		
		if LOG_LEVEL<=LOG_DEBUG:
			print("\n[DEBUG]Front values\n",pop_with_fronts.front.unique())

		if "fit_stable" in pop_with_fronts.columns:
			if LOG_LEVEL<=LOG_WARNING:
				print("\n[WARNING]Removing stability from objectives\n")
				fit=pop_with_fronts.filter(like="fit_")
				fit=fit.add(fit.fit_stable,axis='index')
				pop_with_fronts.loc[:,fit.columns]=fit
				pop_with_fronts.drop("fit_stable",axis=1,inplace=True)
		for front in pop_with_fronts.front.unique():
			pop_front=pop_with_fronts[pop_with_fronts.front==front]
			L=len(pop_front.index)
			pop_front["cr_dist"]=0
			if LOG_LEVEL<=LOG_DEBUG:
				print("\n[DEBUG]Front",front," with pop\n",pop_front)
			for obj in pop_front.filter(like="fit_").columns:
				if LOG_LEVEL<=LOG_DEBUG:
					print("\n[DEBUG]Objective\n",obj)
				sorted_obj=pop_front.sort_values(by=obj,ascending=False,axis='index')
				if LOG_LEVEL<=LOG_DEBUG:
					print("\n[DEBUG]Sorted\n",sorted_obj.loc[:,obj])
				sorted_obj.loc[:,"cr_dist"]=sorted_obj.shift(1).loc[:,obj]-sorted_obj.shift(-1).loc[:,obj]
				sorted_obj.ix[0,"cr_dist"]=np.inf
				sorted_obj.ix[L-1,"cr_dist"]=np.inf
				if LOG_LEVEL<=LOG_DEBUG:
					print("\n[DEBUG]Cr dist\n",sorted_obj)

				pop_front.loc[sorted_obj.index,"cr_dist"]=pop_front.loc[sorted_obj.index,"cr_dist"].add(sorted_obj.cr_dist,axis='index')
			if LOG_LEVEL<=LOG_INFO:
				print("\n[INFO]crowding_distance for front ",front,"\n",pop_front)
			pop_with_fronts.loc[pop_front.index,"cr_dist"]=pop_front.cr_dist
		if LOG_LEVEL<=LOG_INFO:
			print("\n[INFO]Full pop\n",pop_with_fronts)

		return pop_with_fronts


	def eval_pop(self,population,verbose=False):
		if LOG_LEVEL<=LOG_INFO:
			print("\n[INFO]Evaluating population\n",population)
		self.run_launcher.create_pop(population.to_dict(orient="index"),
									self.param_paths,
									self.log_paths)
		self.run_launcher.run_batch("worlds",self.worlds_path,self.log_paths)
		scores=self.run_launcher.wait_for_fitness(self.log_paths.copy())
		
		scores=scores[scores.columns.drop(scores.filter(like="Unnamed").columns)]
		scores.dropna(axis="columns",inplace=True)
		saved_df=pd.concat([population,scores],axis=1)
		saved_df["gen"]=self.nb_gen
		saved_df.to_csv(os.path.join(self.trial_dir,"gen"+str(self.nb_gen)+".csv"))
		scores=scores.add(scores.fit_stable,axis='index')
		scores.drop("fit_stable",axis=1,inplace=True)
		evaluated=pd.concat([population,scores],axis=1)
		if LOG_LEVEL<=LOG_INFO:
			print("\n[INFO]Evaluated pop\n",evaluated)
		return evaluated

	def is_stop(self):
		if self.nb_gen>self.max_nb_gen:
			print("\n[INFO]Finished after",self.nb_gen,"generations in",np.round(time.time()-self.start_time),"s")
			return True
	def flatten_params(self):
		nb_par=len(self.dofs)
		self._bound_low=np.empty(nb_par, np.float16)
		self._bound_high=np.empty(nb_par, np.float16)
		self._params=[]
		self.dof_names=[]
		i=0
		for dof_name,dof_bounds in self.dofs.items():
			self._bound_low[i]=dof_bounds[0]
			self._bound_high[i]=dof_bounds[1]
			self.dof_names.append(dof_name)
			i+=1

class PythonEvolutionController(EvolutionController):
	def __init__(self,config_file):
		params=yaml.load(open(config_file, 'r'))

		EvolutionController.__init__(self,params)
		self.run_launcher=PythonLauncher(self.world_dir,trial_dir=self.trial_dir)

class CppEvolutionController(EvolutionController):
	def __init__(self,config_file):
		params=yaml.load(open(config_file, 'r'))
		EvolutionController.__init__(self,params)

		self.run_launcher=CppLauncher(self.world_dir,trial_dir=self.trial_dir)